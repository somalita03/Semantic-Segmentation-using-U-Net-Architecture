# -*- coding: utf-8 -*-
"""2dUnet.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1tyRIXjJU-o2mfs-ildHtGtc_rvQ79R4S
"""

! pip install kaggle

! mkdir -p ~/.kaggle
! cp kaggle.json ~/.kaggle/
! chmod 600 ~/.kaggle/kaggle.json

! kaggle datasets download -d carlolepelaars/camvid

from zipfile import ZipFile
dataset = '/content/camvid.zip'
with ZipFile(dataset,'r') as zip:
  zip.extractall()
  print("done")

import os
import numpy as np
import pandas as pd
import re
import matplotlib.pyplot as plt
import cv2
import tensorflow as tf

## defining a frame for image and mask storage
framObjTrain = {'img' : [],
           'mask' : []
          }

framObjValidation = {'img' : [],
           'mask' : []
          }

## defining data Loader function
def LoadData( frameObj = None, imgPath = None, maskPath = None, shape = 256):
    imgNames = os.listdir(imgPath)
    maskNames = []

    ## generating mask names
    for mem in imgNames:
        maskNames.append(re.sub('\.png', '_L.png', mem))

    imgAddr = imgPath + '/'
    maskAddr = maskPath + '/'

    for i in range (len(imgNames)):
        img = plt.imread(imgAddr + imgNames[i])
        mask = plt.imread(maskAddr + maskNames[i])

        img = cv2.resize(img, (shape, shape))
        mask = cv2.resize(mask, (shape, shape))

        frameObj['img'].append(img)
        frameObj['mask'].append(mask)

    return frameObj

framObjTrain = LoadData( framObjTrain, imgPath = '/content/CamVid/train', maskPath = '/content/CamVid/train_labels'
         , shape = 256)

framObjValidation  = LoadData( framObjValidation, imgPath = '/content/CamVid/val', maskPath = '/content/CamVid/val_labels'
         , shape = 256)

plt.subplot(1,2,1)
plt.imshow(framObjTrain['img'][1])
plt.subplot(1,2,2)
plt.imshow(framObjTrain['mask'][1])
plt.show()

# this block essentially performs 2 convolution

def Conv2dBlock(inputTensor, numFilters, kernelSize = 3, doBatchNorm = True):
    #first Conv
    x = tf.keras.layers.Conv2D(filters = numFilters, kernel_size = (kernelSize, kernelSize),
                              kernel_initializer = 'he_normal', padding = 'same') (inputTensor)

    if doBatchNorm:
        x = tf.keras.layers.BatchNormalization()(x)

    x =tf.keras.layers.Activation('relu')(x)

    #Second Conv
    x = tf.keras.layers.Conv2D(filters = numFilters, kernel_size = (kernelSize, kernelSize),
                              kernel_initializer = 'he_normal', padding = 'same') (x)
    if doBatchNorm:
        x = tf.keras.layers.BatchNormalization()(x)

    x = tf.keras.layers.Activation('relu')(x)

    return x


# Now defining Unet
def GiveMeUnet(inputImage, numFilters = 16, droupouts = 0.1, doBatchNorm = True):
    # defining encoder Path
    c1 = Conv2dBlock(inputImage, numFilters * 1, kernelSize = 3, doBatchNorm = doBatchNorm)
    p1 = tf.keras.layers.MaxPooling2D((2,2))(c1)
    p1 = tf.keras.layers.Dropout(droupouts)(p1)

    c2 = Conv2dBlock(p1, numFilters * 2, kernelSize = 3, doBatchNorm = doBatchNorm)
    p2 = tf.keras.layers.MaxPooling2D((2,2))(c2)
    p2 = tf.keras.layers.Dropout(droupouts)(p2)

    c3 = Conv2dBlock(p2, numFilters * 4, kernelSize = 3, doBatchNorm = doBatchNorm)
    p3 = tf.keras.layers.MaxPooling2D((2,2))(c3)
    p3 = tf.keras.layers.Dropout(droupouts)(p3)

    c4 = Conv2dBlock(p3, numFilters * 8, kernelSize = 3, doBatchNorm = doBatchNorm)
    p4 = tf.keras.layers.MaxPooling2D((2,2))(c4)
    p4 = tf.keras.layers.Dropout(droupouts)(p4)

    c5 = Conv2dBlock(p4, numFilters * 16, kernelSize = 3, doBatchNorm = doBatchNorm)

    # defining decoder path
    u6 = tf.keras.layers.Conv2DTranspose(numFilters*8, (3, 3), strides = (2, 2), padding = 'same')(c5)
    u6 = tf.keras.layers.concatenate([u6, c4])
    u6 = tf.keras.layers.Dropout(droupouts)(u6)
    c6 = Conv2dBlock(u6, numFilters * 8, kernelSize = 3, doBatchNorm = doBatchNorm)

    u7 = tf.keras.layers.Conv2DTranspose(numFilters*4, (3, 3), strides = (2, 2), padding = 'same')(c6)

    u7 = tf.keras.layers.concatenate([u7, c3])
    u7 = tf.keras.layers.Dropout(droupouts)(u7)
    c7 = Conv2dBlock(u7, numFilters * 4, kernelSize = 3, doBatchNorm = doBatchNorm)

    u8 = tf.keras.layers.Conv2DTranspose(numFilters*2, (3, 3), strides = (2, 2), padding = 'same')(c7)
    u8 = tf.keras.layers.concatenate([u8, c2])
    u8 = tf.keras.layers.Dropout(droupouts)(u8)
    c8 = Conv2dBlock(u8, numFilters * 2, kernelSize = 3, doBatchNorm = doBatchNorm)

    u9 = tf.keras.layers.Conv2DTranspose(numFilters*1, (3, 3), strides = (2, 2), padding = 'same')(c8)
    u9 = tf.keras.layers.concatenate([u9, c1])
    u9 = tf.keras.layers.Dropout(droupouts)(u9)
    c9 = Conv2dBlock(u9, numFilters * 1, kernelSize = 3, doBatchNorm = doBatchNorm)

    output = tf.keras.layers.Conv2D(3, (1, 1), activation = 'sigmoid')(c9)
    model = tf.keras.Model(inputs = [inputImage], outputs = [output])
    return model

## instanctiating model
inputs = tf.keras.layers.Input((256,256 , 3))
myTransformer = GiveMeUnet(inputs, droupouts= 0.07)
myTransformer.compile(optimizer = 'Adam', loss = 'binary_crossentropy', metrics = ['accuracy'] )

retVal = myTransformer.fit(np.array(framObjTrain['img']), np.array(framObjTrain['mask']), epochs = 200, verbose = 0)

plt.plot(retVal.history['loss'], label = 'training_loss')
plt.plot(retVal.history['accuracy'], label = 'training_accuracy')
plt.legend()
plt.grid(True)

def predict16 (valMap, model, shape = 256):
      ## getting and proccessing val data
      img = valMap['img']
      mask = valMap['mask']
      mask = mask[0:16]

      imgProc = img [0:16]
      imgProc = np.array(img)

      predictions = model.predict(imgProc)
      for i in range(len(predictions)):
          predictions[i] = cv2.merge((predictions[i,:,:,0],predictions[i,:,:,1],predictions[i,:,:,2]))

      return predictions, imgProc, mask




  def Plotter(img, predMask, groundTruth):
      plt.figure(figsize=(7,7))

      plt.subplot(1,3,1)
      plt.imshow(img)
      plt.title('image')

      plt.subplot(1,3,2)
      plt.imshow(predMask)
      plt.title('Predicted Mask')

      plt.subplot(1,3,3)
      plt.imshow(groundTruth)
      plt.title('actual Mask')

sixteenPrediction, actuals, masks = predict16(framObjValidation, myTransformer)

Plotter(actuals[1], sixteenPrediction[1], masks[1])

Plotter(actuals[2], sixteenPrediction[2], masks[2])

Plotter(actuals[3], sixteenPrediction[3], masks[3])

Plotter(actuals[4], sixteenPrediction[4], masks[4])

Plotter(actuals[9], sixteenPrediction[9], masks[9])

Plotter(actuals[11], sixteenPrediction[11], masks[11])

Plotter(actuals[14], sixteenPrediction[14], masks[14])

Plotter(actuals[7], sixteenPrediction[7], masks[7])

Plotter(actuals[10],sixteenPrediction[10],masks[10])

import numpy as np
import tensorflow as tf
from sklearn.metrics import confusion_matrix

def calculate_class_accuracies(y_true, y_pred, num_classes):
    """
    Calculate accuracy for each class.

    Parameters:
    y_true (numpy array): True mask labels.
    y_pred (numpy array): Predicted mask labels.
    num_classes (int): Number of classes.

    Returns:
    dict: A dictionary with class index as key and accuracy as value.
    """
    accuracies = {}
    for i in range(num_classes):
        true_class = (y_true == i).astype(int)  # Changed to int
        pred_class = (y_pred == i).astype(int)  # Changed to int

        # Calculate confusion matrix
        tn, fp, fn, tp = confusion_matrix(true_class.flatten(), pred_class.flatten(), labels=[0, 1]).ravel()

        # Accuracy for class i
        accuracy = tp / (tp + fn) if (tp + fn) > 0 else 0
        accuracies[i] = 1-accuracy

    return accuracies

# Example usage with dummy data
num_classes = 32
batch_size = 4  # Assuming you have a batch size of 4
height, width = 256, 256  # Assuming image and mask size is 256x256

# Dummy true masks and predicted masks
y_true = np.random.randint(0, num_classes, size=(batch_size, height, width))
y_pred = np.random.randint(0, num_classes, size=(batch_size, height, width))

# Calculate accuracies
class_accuracies = calculate_class_accuracies(y_true, y_pred, num_classes)

# Print accuracies
for cls, accuracy in class_accuracies.items():
    print(f"Class {cls}: Accuracy = {accuracy:.4f}")

import matplotlib.pyplot as plt

def visualize_predictions(images, true_masks, pred_masks, num_classes):
    """
    Visualize a few examples of true and predicted masks.

    Parameters:
    images (numpy array): Input images.
    true_masks (numpy array): True mask labels.
    pred_masks (numpy array): Predicted mask labels.
    num_classes (int): Number of classes.
    """
    batch_size = images.shape[0]
    for i in range(min(batch_size, 5)):  # Visualize up to 5 samples
        fig, axes = plt.subplots(1, 3, figsize=(15, 5))

        # Display image
        axes[0].imshow(images[i])
        axes[0].set_title('Input Image')

        # Display true mask
        true_mask_rgb = label_to_rgb(true_masks[i], num_classes)
        axes[1].imshow(true_mask_rgb)
        axes[1].set_title('True Mask')

        # Display predicted mask
        pred_mask_rgb = label_to_rgb(pred_masks[i], num_classes)
        axes[2].imshow(pred_mask_rgb)
        axes[2].set_title('Predicted Mask')

        plt.show()

def label_to_rgb(label, num_classes):
    """
    Convert label mask to RGB image for visualization.

    Parameters:
    label (numpy array): Label mask.
    num_classes (int): Number of classes.

    Returns:
    numpy array: RGB image.
    """
    colors = plt.cm.get_cmap('tab20', num_classes)
    rgb_image = colors(label / (num_classes - 1))[:, :, :3]
    return rgb_image

# Example usage with dummy data
num_classes = 32
batch_size = 4  # Assuming you have a batch size of 4
height, width = 256, 256  # Assuming image and mask size is 256x256

# Dummy data
images = np.random.rand(batch_size, height, width, 3)
true_masks = np.random.randint(0, num_classes, size=(batch_size, height, width))
pred_masks = np.random.randint(0, num_classes, size=(batch_size, height, width))

visualize_predictions(images, true_masks, pred_masks, num_classes)

